# ğŸ“˜ 09. ì´ì§„ ë²¡í„° (Binary Vectors)

ì´ì§„ ë²¡í„°(Binary Vector)ëŠ” ë²¡í„°ì˜ ê° ì°¨ì›ì„ **0 ë˜ëŠ” 1ì˜ ë¹„íŠ¸**ë¡œ í‘œí˜„í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.  
ì¼ë°˜ì ì¸ float ë²¡í„°(32ë¹„íŠ¸)ì— ë¹„í•´ **ë©”ëª¨ë¦¬ë¥¼ 1/32ë¡œ ì ˆì•½**í•˜ë©´ì„œë„ ë¹ ë¥¸ ê²€ìƒ‰ ì†ë„ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

> ğŸ” **í•µì‹¬ ê°œë…:**  
> ì´ì§„ ë²¡í„°ëŠ” ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ê³¼ ê²€ìƒ‰ ì†ë„ê°€ ì¤‘ìš”í•œ **ì´ˆëŒ€ê·œëª¨ ë²¡í„° ê²€ìƒ‰ ì‹œìŠ¤í…œ**ì—ì„œ í™œìš©ë©ë‹ˆë‹¤.  
> ì •í™•ë„ëŠ” ë‹¤ì†Œ ë–¨ì–´ì§€ì§€ë§Œ, **1ì°¨ í•„í„°ë§(coarse search)** í›„ **ì¬ë­í‚¹(re-ranking)** ì„ í†µí•´  
> ì‹¤ìš©ì ì¸ ê²€ìƒ‰ í’ˆì§ˆì„ í™•ë³´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## 1) ì´ì§„ ë²¡í„°ë€?

### ì¼ë°˜ ë²¡í„° vs ì´ì§„ ë²¡í„°

| êµ¬ë¶„ | float32 ë²¡í„° | ì´ì§„ ë²¡í„° (bit) |
|------|-------------|----------------|
| **í‘œí˜„ ë°©ì‹** | ê° ì°¨ì›ì´ 32ë¹„íŠ¸ ë¶€ë™ì†Œìˆ˜ì  | ê° ì°¨ì›ì´ 1ë¹„íŠ¸ (0 ë˜ëŠ” 1) |
| **768ì°¨ì› ì €ì¥ ìš©ëŸ‰** | 3,072 bytes (768 Ã— 4) | 96 bytes (768 Ã· 8) |
| **ë©”ëª¨ë¦¬ íš¨ìœ¨** | ê¸°ì¤€ | **1/32 (97% ì ˆê°)** |
| **ê²€ìƒ‰ ì†ë„** | ë³´í†µ | **ë§¤ìš° ë¹ ë¦„** |
| **ì •í™•ë„** | ë†’ìŒ | ë‚®ìŒ (ì •ë³´ ì†ì‹¤) |
| **ì£¼ìš” ìš©ë„** | ì •ë°€ ê²€ìƒ‰, ì†Œê·œëª¨ ë°ì´í„° | ëŒ€ê·œëª¨ 1ì°¨ í•„í„°ë§ |

### pgvectorì˜ bit íƒ€ì…

pgvectorëŠ” PostgreSQLì˜ `bit` íƒ€ì…ì„ í™œìš©í•˜ì—¬ ì´ì§„ ë²¡í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

```sql
-- 768ì°¨ì› ì´ì§„ ë²¡í„° ì»¬ëŸ¼ ìƒì„±
CREATE TABLE vector.binary_embeddings (
    id BIGSERIAL PRIMARY KEY,
    chunk_text TEXT,
    binary_vec BIT(768)  -- 768ë¹„íŠ¸ = 96ë°”ì´íŠ¸
);
```
---

## 2) Binary Quantization (ì´ì§„ ì–‘ìí™”)
### ê°œë…

Binary Quantizationì€ **float ë²¡í„°ë¥¼ ì´ì§„ ë²¡í„°ë¡œ ë³€í™˜**í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ì…ë‹ˆë‹¤.  
ê° ì°¨ì›ì˜ ê°’ì„ ì„ê³„ê°’ ê¸°ì¤€ìœ¼ë¡œ 0 ë˜ëŠ” 1ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

### ë³€í™˜ ë°©ì‹
#### â‘  ê¸°ë³¸ ë°©ì‹: ë¶€í˜¸ ê¸°ë°˜ (Sign-based)

ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•ìœ¼ë¡œ, **0ë³´ë‹¤ í¬ë©´ 1, ì‘ê±°ë‚˜ ê°™ìœ¼ë©´ 0**ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

```python
import numpy as np

# float32 ë²¡í„°
float_vec = np.array([0.82, -0.15, 0.45, -0.67, 0.03])

# ì´ì§„ ë³€í™˜: 0ë³´ë‹¤ í¬ë©´ 1, ì•„ë‹ˆë©´ 0
binary_vec = (float_vec > 0).astype(int)

print(binary_vec)  # [1, 0, 1, 0, 1]
```

#### â‘¡ ì¤‘ê°„ê°’ ê¸°ì¤€ (Median-based)

ë²¡í„°ì˜ **ì¤‘ê°„ê°’(median)ì„ ê¸°ì¤€**ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë” ê· í˜• ì¡íŒ ë¶„í¬ë¥¼ ë§Œë“­ë‹ˆë‹¤.

```python
# ì¤‘ê°„ê°’ ê³„ì‚°
median = np.median(float_vec)  # 0.03

# ì¤‘ê°„ê°’ë³´ë‹¤ í¬ë©´ 1
binary_vec = (float_vec > median).astype(int)

print(binary_vec)  # [1, 0, 1, 0, 0]
```

### Python ì˜ˆì œ: float â†’ binary ë³€í™˜ ë° ì €ì¥

```python
from sentence_transformers import SentenceTransformer
import psycopg2
import numpy as np

# 1) ì„ë² ë”© ëª¨ë¸ ë¡œë“œ
model = SentenceTransformer("nomic-ai/nomic-embed-text-v1.5")

# 2) í…ìŠ¤íŠ¸ ì„ë² ë”© ìƒì„± (float32)
text = "pgvectorëŠ” PostgreSQLì—ì„œ ë²¡í„° ê²€ìƒ‰ì„ ì§€ì›í•©ë‹ˆë‹¤"
float_embedding = model.encode(text)

# 3) ì´ì§„ ë³€í™˜ (0ë³´ë‹¤ í¬ë©´ 1)
binary_embedding = (float_embedding > 0).astype(int)

# 4) ë¹„íŠ¸ ë¬¸ìì—´ë¡œ ë³€í™˜ (PostgreSQL bit íƒ€ì…ìš©)
bit_string = ''.join(map(str, binary_embedding))

# 5) PostgreSQL ì €ì¥
conn = psycopg2.connect(...)
cur = conn.cursor()

cur.execute("""
    INSERT INTO vector.binary_embeddings (chunk_text, binary_vec)
    VALUES (%s, %s::bit(768))
""", (text, bit_string))

conn.commit()
cur.close()
conn.close()

print(f"ì›ë³¸ í¬ê¸°: {float_embedding.nbytes} bytes")  # 3072 bytes
print(f"ì´ì§„ í¬ê¸°: {len(bit_string) // 8} bytes")    # 96 bytes
```
---

## 3) ì´ì§„ ë²¡í„° ê±°ë¦¬ í•¨ìˆ˜
pgvectorëŠ” ì´ì§„ ë²¡í„° ê°„ ìœ ì‚¬ë„ë¥¼ ê³„ì‚°í•˜ëŠ” **Hamming Distance** ì—°ì‚°ìë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### Hamming Distanceë€?
ë‘ ì´ì§„ ë²¡í„°ì—ì„œ **ì„œë¡œ ë‹¤ë¥¸ ë¹„íŠ¸ì˜ ê°œìˆ˜**ë¥¼ ì„¸ëŠ” ê±°ë¦¬ ì²™ë„ì…ë‹ˆë‹¤.

```
ë²¡í„° A: 1 0 1 1 0
ë²¡í„° B: 1 1 1 0 0
         â†“ â†“ â†“ â†“ â†“
ì°¨ì´:    0 1 0 1 0  â†’ ë‹¤ë¥¸ ë¹„íŠ¸ 2ê°œ

Hamming Distance = 2
```

### pgvector ì—°ì‚°ì

| ì—°ì‚°ì | ì˜ë¯¸ | ì„¤ëª… |
|--------|------|------|
| `<~>` | Hamming Distance | ë‹¤ë¥¸ ë¹„íŠ¸ ê°œìˆ˜ (ì‘ì„ìˆ˜ë¡ ìœ ì‚¬) |

### ê²€ìƒ‰ ì˜ˆì œ

```sql
-- ì¿¼ë¦¬ ë²¡í„° (ì´ì§„)
-- ì˜ˆ: '10110...' (768ë¹„íŠ¸)

SELECT 
    id,
    chunk_text,
    binary_vec <~> '10110...'::bit(768) AS hamming_distance
FROM vector.binary_embeddings
ORDER BY hamming_distance
LIMIT 10;
```
---

## 4) ì¬ë­í‚¹ (Re-ranking) ì „ëµ
ì´ì§„ ë²¡í„°ëŠ” ì •ë³´ ì†ì‹¤ì´ í¬ê¸° ë•Œë¬¸ì—, **ë‹¨ë…ìœ¼ë¡œëŠ” ê²€ìƒ‰ í’ˆì§ˆì´ ë–¨ì–´ì§‘ë‹ˆë‹¤**.  
ì´ë¥¼ ë³´ì™„í•˜ê¸° ìœ„í•´ **2ë‹¨ê³„ ê²€ìƒ‰(Coarse-to-Fine)** ì „ëµì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

### Coarse-to-Fine ê²€ìƒ‰ êµ¬ì¡°

```
[1ë‹¨ê³„: Coarse Search - ì´ì§„ ë²¡í„°]
  ì „ì²´ 100ë§Œ ê°œ â†’ ë¹ ë¥¸ Hamming Distance ê²€ìƒ‰
  â†“ ìƒìœ„ 100ê°œ í›„ë³´ ì¶”ì¶œ (0.01ì´ˆ)

[2ë‹¨ê³„: Fine Search - float ë²¡í„°]
  100ê°œ í›„ë³´ â†’ ì •ë°€í•œ ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ì¬ê³„ì‚°
  â†“ ìµœì¢… 10ê°œ ì„ íƒ (0.02ì´ˆ)

ì´ ê²€ìƒ‰ ì‹œê°„: 0.03ì´ˆ
ì •í™•ë„: float ì§ì ‘ ê²€ìƒ‰ê³¼ ìœ ì‚¬ (95%+)
```

### ì¬ë­í‚¹ êµ¬í˜„ ì˜ˆì œ

#### â‘  í…Œì´ë¸” êµ¬ì¡° (ì´ì§„ + float í˜¼í•© ì €ì¥)

```sql
CREATE TABLE vector.hybrid_embeddings (
    id BIGSERIAL PRIMARY KEY,
    chunk_text TEXT,
    binary_vec BIT(768),           -- 1ì°¨ ê²€ìƒ‰ìš©
    float_vec VECTOR(768)          -- 2ì°¨ ì¬ë­í‚¹ìš©
);

-- ì´ì§„ ë²¡í„°ìš© ì¸ë±ìŠ¤
CREATE INDEX idx_binary_hamming ON vector.hybrid_embeddings 
USING ivfflat (binary_vec bit_hamming_ops)
WITH (lists = 100);

-- float ë²¡í„°ëŠ” ì¸ë±ìŠ¤ ì—†ì´ ì§ì ‘ ê³„ì‚° (í›„ë³´ê°€ ì ìœ¼ë¯€ë¡œ)
```

#### â‘¡ Python ì¬ë­í‚¹ êµ¬í˜„

```python
import psycopg2
import numpy as np
from sentence_transformers import SentenceTransformer

model = SentenceTransformer("nomic-ai/nomic-embed-text-v1.5")

def search_with_reranking(query_text, top_k=10, candidate_size=100):
    # 1) ì¿¼ë¦¬ ì„ë² ë”© ìƒì„±
    float_query = model.encode(query_text)
    binary_query = (float_query > 0).astype(int)
    bit_string = ''.join(map(str, binary_query))
    
    conn = psycopg2.connect(...)
    cur = conn.cursor()
    
    # 2) 1ì°¨ ê²€ìƒ‰: ì´ì§„ ë²¡í„°ë¡œ ìƒìœ„ 100ê°œ í›„ë³´ ì¶”ì¶œ
    cur.execute(f"""
        SELECT id, chunk_text, float_vec
        FROM vector.hybrid_embeddings
        ORDER BY binary_vec <~> %s::bit(768)
        LIMIT %s
    """, (bit_string, candidate_size))
    
    candidates = cur.fetchall()
    
    # 3) 2ì°¨ ì¬ë­í‚¹: float ë²¡í„°ë¡œ ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê³„ì‚°
    results = []
    for cand_id, text, float_vec_str in candidates:
        # PostgreSQL vector íƒ€ì… íŒŒì‹±
        float_vec = np.array([float(x) for x in float_vec_str.strip('[]').split(',')])
        
        # ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê³„ì‚°
        similarity = np.dot(float_query, float_vec) / (
            np.linalg.norm(float_query) * np.linalg.norm(float_vec)
        )
        results.append((cand_id, text, similarity))
    
    # 4) ìœ ì‚¬ë„ ê¸°ì¤€ ì •ë ¬ í›„ ìƒìœ„ kê°œ ë°˜í™˜
    results.sort(key=lambda x: x[2], reverse=True)
    
    cur.close()
    conn.close()
    
    return results[:top_k]

# ì‚¬ìš©
results = search_with_reranking("PostgreSQL ë²¡í„° ê²€ìƒ‰ ë°©ë²•", top_k=5)
for rank, (doc_id, text, score) in enumerate(results, 1):
    print(f"{rank}. [{score:.4f}] {text[:50]}...")
```

---

## 5) ì´ì§„ ë²¡í„° ì¸ë±ì‹±

### IVFFlat ì¸ë±ìŠ¤ (ê¶Œì¥)
ì´ì§„ ë²¡í„°ëŠ” `bit_hamming_ops` ì—°ì‚°ì í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ IVFFlat ì¸ë±ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

```sql
-- IVFFlat ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_binary_ivfflat ON vector.binary_embeddings
USING ivfflat (binary_vec bit_hamming_ops)
WITH (lists = 100);

-- lists ê°’ ê°€ì´ë“œ
-- ë°ì´í„° 100ë§Œ ê°œ: lists = 1000
-- ë°ì´í„° 10ë§Œ ê°œ:  lists = 100
```

### ì¸ë±ìŠ¤ ì‚¬ìš© ì¿¼ë¦¬

```sql
-- ì¸ë±ìŠ¤ í™œìš© ê²€ìƒ‰
SET ivfflat.probes = 10;  -- íƒìƒ‰í•  í´ëŸ¬ìŠ¤í„° ìˆ˜

SELECT id, chunk_text
FROM vector.binary_embeddings
ORDER BY binary_vec <~> '10110...'::bit(768)
LIMIT 20;
```
---

## 6) ì¥ë‹¨ì  ë° ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤
### ì¥ì 

âœ… **ë©”ëª¨ë¦¬ íš¨ìœ¨:** float32 ëŒ€ë¹„ 1/32 í¬ê¸° (97% ì ˆê°)  
âœ… **ë¹ ë¥¸ ê²€ìƒ‰:** Hamming DistanceëŠ” XOR ë¹„íŠ¸ ì—°ì‚°ìœ¼ë¡œ ë§¤ìš° ë¹ ë¦„  
âœ… **ëŒ€ê·œëª¨ í™•ì¥:** ìˆ˜ì–µ~ìˆ˜ì‹­ì–µ ë²¡í„° ì‹œìŠ¤í…œì—ì„œ 1ì°¨ í•„í„°ë§ì— ìœ ìš©  
âœ… **ë¹„ìš© ì ˆê°:** í´ë¼ìš°ë“œ í™˜ê²½ì—ì„œ ë©”ëª¨ë¦¬ ë¹„ìš© ëŒ€í­ ê°ì†Œ

### ë‹¨ì 

âŒ **ì •ë³´ ì†ì‹¤:** float â†’ binary ë³€í™˜ ì‹œ ì •ë°€ë„ ì†ì‹¤  
âŒ **ì •í™•ë„ í•˜ë½:** ë‹¨ë… ì‚¬ìš© ì‹œ ê²€ìƒ‰ í’ˆì§ˆ ì €í•˜  
âŒ **íŠœë‹ í•„ìš”:** ì¬ë­í‚¹ íŒŒì´í”„ë¼ì¸ êµ¬ì¶• í•„ìš”

### ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤

| ì‹œë‚˜ë¦¬ì˜¤ | ê¶Œì¥ ì—¬ë¶€ | ì´ìœ  |
|----------|----------|------|
| **ë°ì´í„° 1ì²œë§Œ ê°œ ì´í•˜** | âŒ | float32ë¡œ ì¶©ë¶„íˆ ë¹ ë¦„ |
| **ë°ì´í„° 1ì–µ ê°œ ì´ìƒ** | âœ… | ë©”ëª¨ë¦¬/ì†ë„ ì´ì  ëª…í™• |
| **ì •í™•ë„ ìµœìš°ì„ ** | âŒ | float32 ë˜ëŠ” halfvec ì‚¬ìš© |
| **ë¹„ìš© ìµœì í™”** | âœ… | í´ë¼ìš°ë“œ ë©”ëª¨ë¦¬ ë¹„ìš© ì ˆê° |
| **í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰** | âœ… | BM25 + binary ì¡°í•© |

---

## 7) ì‹¤ì „ ì˜ˆì œ: 100ë§Œ ê°œ ë¬¸ì„œ ê²€ìƒ‰ ì‹œìŠ¤í…œ

### ì‹œë‚˜ë¦¬ì˜¤
- 100ë§Œ ê°œì˜ ë…¼ë¬¸ ì´ˆë¡ (768ì°¨ì› ì„ë² ë”©)
- ë©”ëª¨ë¦¬ ì œì•½: 8GB RAM
- ìš”êµ¬ì‚¬í•­: ê²€ìƒ‰ ì†ë„ < 100ms

### êµ¬í˜„

```sql
-- 1) í…Œì´ë¸” ìƒì„±
CREATE TABLE vector.papers (
    id BIGSERIAL PRIMARY KEY,
    title TEXT,
    abstract TEXT,
    binary_vec BIT(768),
    float_vec VECTOR(768)
);

-- 2) ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_papers_binary ON vector.papers
USING ivfflat (binary_vec bit_hamming_ops)
WITH (lists = 1000);

-- 3) 1ì°¨ ê²€ìƒ‰ (ì´ì§„)
SET ivfflat.probes = 20;

WITH candidates AS (
    SELECT id, title, abstract, float_vec
    FROM vector.papers
    ORDER BY binary_vec <~> :binary_query::bit(768)
    LIMIT 100
)
-- 4) 2ì°¨ ì¬ë­í‚¹ (float)
SELECT 
    id, 
    title,
    float_vec <=> :float_query::vector(768) AS distance
FROM candidates
ORDER BY distance
LIMIT 10;
```

### ì„±ëŠ¥ ë¹„êµ

| ë°©ì‹ | ë©”ëª¨ë¦¬ ì‚¬ìš© | ê²€ìƒ‰ ì‹œê°„ | ì •í™•ë„ |
|------|------------|----------|--------|
| **float32ë§Œ** | 3GB | 150ms | 100% |
| **binaryë§Œ** | 96MB | 30ms | 75% |
| **binary + ì¬ë­í‚¹** | 100MB | 50ms | 95% |

---

## 8) ì£¼ì˜ì‚¬í•­

### âš ï¸ ëª¨ë¸ ì¼ê´€ì„±

ì´ì§„ ë³€í™˜ ë°©ì‹(ë¶€í˜¸ ê¸°ë°˜ vs ì¤‘ê°„ê°’ ê¸°ì¤€)ì€ **ì €ì¥ ì‹œì™€ ê²€ìƒ‰ ì‹œ ë™ì¼**í•´ì•¼ í•©ë‹ˆë‹¤.

```python
# âŒ ì˜ëª»ëœ ì˜ˆ
# ì €ì¥ ì‹œ: ë¶€í˜¸ ê¸°ë°˜
binary_stored = (embedding > 0)

# ê²€ìƒ‰ ì‹œ: ì¤‘ê°„ê°’ ê¸°ì¤€ (ë‹¤ë¥¸ ë°©ì‹!)
median = np.median(query_embedding)
binary_query = (query_embedding > median)

# ê²°ê³¼: ê²€ìƒ‰ ê²°ê³¼ê°€ ë¬´ì˜ë¯¸í•¨
```

```python
# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ
# ì €ì¥/ê²€ìƒ‰ ëª¨ë‘ ë™ì¼í•œ ë°©ì‹ ì‚¬ìš©
def to_binary(vec):
    return (vec > 0).astype(int)

# ì €ì¥
binary_stored = to_binary(embedding)

# ê²€ìƒ‰
binary_query = to_binary(query_embedding)
```

### âš ï¸ ì°¨ì› ìˆ˜ í™•ì¸

PostgreSQL `bit` íƒ€ì…ì€ **ê³ ì • ê¸¸ì´**ì´ë¯€ë¡œ ì°¨ì› ìˆ˜ê°€ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.

```sql
-- 768ì°¨ì›ìœ¼ë¡œ ì •ì˜
CREATE TABLE ... (binary_vec BIT(768));

-- âŒ ì—ëŸ¬: 1024ë¹„íŠ¸ë¥¼ 768ë¹„íŠ¸ ì»¬ëŸ¼ì— ì‚½ì… ë¶ˆê°€
INSERT INTO ... VALUES ('10110...(1024ë¹„íŠ¸)...'::bit(768));

-- âœ… ì •í™•íˆ 768ë¹„íŠ¸ë§Œ í—ˆìš©
INSERT INTO ... VALUES ('10110...(768ë¹„íŠ¸)...'::bit(768));
```

---

## 9) ìš”ì•½

### í•µì‹¬ í¬ì¸íŠ¸

1. **ì´ì§„ ë²¡í„° = ë©”ëª¨ë¦¬ 1/32 ì ˆì•½**  
   float32 ëŒ€ë¹„ 97% ë©”ëª¨ë¦¬ ì ˆê°, ì´ˆëŒ€ê·œëª¨ ì‹œìŠ¤í…œì— í•„ìˆ˜

2. **Binary Quantization**  
   float â†’ binary ë³€í™˜ ì‹œ ì¼ê´€ëœ ë°©ì‹ ìœ ì§€ (ë¶€í˜¸ ë˜ëŠ” ì¤‘ê°„ê°’ ê¸°ì¤€)

3. **ì¬ë­í‚¹ í•„ìˆ˜**  
   ì´ì§„ ë²¡í„°(coarse) + float ë²¡í„°(fine) 2ë‹¨ê³„ ê²€ìƒ‰ìœ¼ë¡œ ì •í™•ë„ ë³´ì™„

4. **ì ìš© ê¸°ì¤€**
    - ë°ì´í„° 1ì–µ ê°œ ì´ìƒ â†’ ì ê·¹ ê¶Œì¥
    - 1ì²œë§Œ ê°œ ì´í•˜ â†’ float32ê°€ ë” ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì 

5. **Hamming Distance**  
   pgvectorëŠ” `<~>` ì—°ì‚°ìë¡œ ì´ì§„ ë²¡í„° ê²€ìƒ‰ ì§€ì›

---