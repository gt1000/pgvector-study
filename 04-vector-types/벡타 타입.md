# 📘 04. 벡터 타입 (Vector Types)

pgvector는 다양한 데이터 타입과 용도에 맞춰 여러 종류의 벡터 타입을 지원합니다.  
각 타입은 **정확도, 메모리 사용량, 검색 속도** 간의 트레이드오프를 가지고 있으며,  
서비스 규모와 요구사항에 따라 적절한 타입을 선택해야 합니다.

> 🔎 **중요:**  
> 벡터 타입은 **테이블 생성 시** 결정되며, 이후 변경하려면 테이블 재생성이 필요합니다.  
> 또한 **저장 시 사용한 타입과 검색 시 사용하는 타입이 일치**해야 정확한 유사도 계산이 가능합니다.

---

## 1) vector (float32) - 기본 타입

pgvector의 **기본 벡터 타입**으로, 32비트 부동소수점 숫자로 구성된 고정 길이 벡터입니다.

### 특징
- **최대 차원:** 2,000차원 (v0.8.0 기준)
- **정확도:** 가장 높음 (float32 기준)
- **메모리:** 차원당 4바이트
- **용도:** 정확도가 최우선인 서비스, 중소규모 데이터셋

---

### 정밀도 및 자동 변환

PostgreSQL의 `vector` 타입은 **IEEE 754 표준 float32**를 사용하며,  
애플리케이션에서 전송한 값을 자동으로 float32로 변환하여 저장합니다.

#### 정밀도 범위
- float 32 비트 전체 = 1호(1bit) + 지수(8bits) + 가수(23bits)
- 23비트 가수(mantissa) 기반: log₁₀(2²³) ≈ 6.92자리
- **안전한 범위:** 6자리 유효숫자
- **일반적:** 7자리 유효숫자
- **최대:** 8-9자리 (값에 따라 다름)

> 💡 **실무 참고**  
> 유사도 검색은 상대적 거리 비교이므로, float32의 정밀도 손실은 검색 결과에 영향을 주지 않습니다.  
> 수동으로 자릿수를 제한할 필요 없이, 임베딩 값을 그대로 전송하면 됩니다.

---

### 테이블 생성 예시
```sql
-- DDL: 테이블 생성
CREATE TABLE test1 (
    id BIGSERIAL PRIMARY KEY,
    content TEXT,
    embedding vector(2)
);

-- DML: 데이터 삽입
INSERT INTO test1 (content, embedding)
VALUES ('테스트 데이터', '[0.123456789012, -0.987654321098]');

-- 결과 확인
SELECT id, content, embedding FROM test1;
>> 결과 :  1 	"테스트 데이터"	"[0.12345679,-0.9876543]"
```

### 왜 자릿수가 값마다 다른가?

float32는 **10진수가 아니라 2진수**로 저장되기 때문입니다.

#### 10진수 → 2진수 변환 과정
```
0.123456789012 (10진수)
  ↓ 2진수로 변환
  0.00011111010111000010100011110101110000101000111101...
  ↓ 23비트로 자름
  ↓ 다시 10진수로 표현
  0.12345679 (8자리)

-0.987654321098 (10진수)
  ↓ 2진수로 변환
  -0.11111100100010100001000001100010110100001110010111...
  ↓ 23비트로 자름
  ↓ 다시 10진수로 표현
  -0.9876543 (7자리)
```

#### 핵심 원리

float32는 **23비트**라는 고정된 정밀도를 가지지만, 10진수로 표현할 때 자릿수는 값에 따라 달라집니다.

**이진수 표현 특성:**
```
0.5    → 정확히 표현 가능 (2진수: 0.1)
0.1    → 무한소수 (2진수: 0.00011001100110011...)
0.3    → 무한소수 (2진수: 0.010011001100110011...)
```

**비유:**
> 같은 23비트 저장 공간을 사용하지만,  
> 10진수로 "읽을 때" 자릿수가 다르게 보입니다.  
> 마치 같은 1MB 파일이라도 압축 효율이 다른 것처럼.

#### 실제 테스트
```sql
SELECT 
    0.1::real AS "1",           -- 0.1
    0.2::real AS "2",           -- 0.2
    0.3::real AS "3",           -- 0.3
    0.123456789::real AS "8자리",   -- 0.12345679
    0.987654321::real AS "7자리";   -- 0.9876543
```

**결과:**

| 1 | 2 | 3 | 8자리 | 7자리 |
|---|---|---|-------|-------|
| 0.1 | 0.2 | 0.3 | 0.12345679 | 0.9876543 |

**결론:**  
같은 23비트 정밀도를 사용하지만, 10진수로 표현했을 때 자릿수가 다르게 보입니다.  
이것이 "6-9자리"라고 범위로 표현하는 이유입니다.

### 저장 공간 계산
```
1536차원 × 4바이트 = 6,144바이트 (약 6KB)
100만 벡터 = 약 6GB
1억 벡터 = 약 600GB
```
---

## 2) halfvec (float16) - 메모리 절약형

16비트 부동소수점을 사용하는 **메모리 효율적인 벡터 타입**입니다.

### 특징
- **최대 차원:** 4000차원
- **정확도:** float32 대비 98-99%
- **메모리:** 차원당 2바이트 (float32의 50%)
- **용도:** 중대형 서비스, 메모리 비용 절감 필요 시

### 테이블 생성 예시

```sql
CREATE TABLE test2 (
    id BIGSERIAL PRIMARY KEY,
    content TEXT,
    embedding halfvec(1536)
);
```

### 정확도 손실이 작은 이유

벡터 검색에서는 절대적인 값보다 **상대적인 거리/순위**가 중요하므로  
Top-10 결과 중 8~9개는 float32와 동일합니다.

```
float32: 1.234567890... (소수점 7자리)
float16: 1.234500000... (소수점 3-4자리)
```

### 메모리 비교

```
float32: 1536차원 × 4바이트 = 6,144바이트
halfvec: 1536차원 × 2바이트 = 3,072바이트 (50% 절감)

100만 벡터 기준:
float32: 약 6GB
halfvec: 약 3GB
```

---

## 3) bit (Binary Vector) - 초고속 검색형

벡터의 각 차원을 양수(1) 또는 음수(0)로 단순화하여 저장하는 **이진 벡터 타입**입니다.

### 특징
- **최대 차원:** 64000비트
- **정확도:** 단독 사용 시 70-80%, 2-stage 검색 시 95%+
- **메모리:** 차원당 1비트 (float32의 1/32)
- **용도:** 수억~수십억 벡터 검색, 1차 필터링

### 테이블 생성 예시

```sql
CREATE TABLE test3 (
                       id BIGSERIAL PRIMARY KEY,
                       content TEXT,
                       embedding_binary bit(2),
                       embedding_full vector(2)
);

-- 데이터 삽입
INSERT INTO test3 (content, embedding_binary, embedding_full)
VALUES (
           '테스트 문서 1',
           B'10',
           '[0.5, -0.3]'
       ),
       (
           '테스트 문서 2',
           B'01',
           '[-0.2, 0.7]'
       ),
       (
           '테스트 문서 3',
           B'11',
           '[0.8, 0.6]'
       );
```

### Two-Stage 검색 전략

binary 타입은 단독 사용보다 **float32와 조합**하여 사용하는 것이 일반적입니다.

```sql
WITH candidates AS (
    SELECT id
    FROM test3
    ORDER BY embedding_binary <~> B'10' --  Hamming Distance
    LIMIT 2
    )
SELECT t.id, t.content, t.embedding_full <=> '[0.4, -0.2]' AS distance -- Cosine Distance
FROM test3 t
    JOIN candidates c ON t.id = c.id
ORDER BY distance
    LIMIT 1;

-- Hamming Distance
 쿼리:    10
 문서1:   10  → 다른 비트 0개 = 거리 0 (가장 가까움)
 문서2:   01  → 다른 비트 2개 = 거리 2
 문서3:   11  → 다른 비트 1개 = 거리 1
 정렬 결과: 문서1(0) < 문서3(1) < 문서2(2)
 >> 역할 : 벡터로 **빠르게 후보 추출** (Stage 1)
-- Cosine Distance
 Cosine Similarity = (A·B) / (|A|×|B|)
 Cosine Distance = 1 - Cosine Similarity
 값이 작을수록 = 유사함
 0 = 완전히 같은 방향
 2 = 완전히 반대 방향
                                 
 쿼리: [0.4, -0.2]
 문서1: [0.5, -0.3]  → 거리 0.001 (매우 유사)
 문서2: [-0.2, 0.7]  → 거리 1.8 (반대 방향)
 문서3: [0.8, 0.6]   → 거리 0.3 (약간 다름)
 정렬 결과: 문서1(0.001) < 문서3(0.3) < 문서2(1.8)
```

### 메모리 비교

```
float32: 1536차원 × 4바이트 = 6,144바이트
bit:     1536차원 ÷ 8        = 192바이트 (약 3% 크기)

100만 벡터 기준:
float32: 약 6GB
bit:     약 192MB (1/32 크기)
```

---

## 4) sparsevec (Sparse Vector) - 희소 벡터형

0이 아닌 요소만 저장하는 **희소 벡터 타입**입니다.

### 특징
- **최대 비영(non-zero) 요소:** 1,000개
- **정확도:** 원본과 동일 (손실 없음)
- **메모리:** 실제 값이 있는 요소만 저장
- **용도:** 추천 시스템, 하이브리드 검색 (키워드 + 벡터)

<details>
<summary>💡 TF-IDF, BM25란?</summary>

**TF-IDF (Term Frequency-Inverse Document Frequency):**  
문서에서 단어의 중요도를 계산하는 통계 기반 방법. 자주 나오지만 흔한 단어는 낮은 점수, 드물게 나오는 단어는 높은 점수 부여.

**BM25 (Best Matching 25):**  
TF-IDF를 개선한 검색 랭킹 알고리즘. 문서 길이 정규화와 포화 함수를 적용해 더 정확한 키워드 매칭 제공.
</details>

### 테이블 생성 예시

```sql
CREATE TABLE test4 (
    user_id BIGINT PRIMARY KEY,
    item_vector sparsevec(10000)  -- 10000개 상품 중 구매한 것만 저장
);
```

### 사용 예시

```sql
-- 사용자가 구매한 상품만 벡터로 표현
INSERT INTO test4 (user_id, item_vector)
VALUES (1, '{1:0.8,5:0.6,127:0.9,523:0.7}/10000');
-- 1번, 5번, 127번, 523번 상품만 구매 이력 있음
```

### 메모리 비교

```
dense vector:  10000차원 × 4바이트 = 40KB
sparse vector: 4개 요소 × 12바이트 = 48바이트 (약 1/1000 크기)
```

---

## 5) 벡터 타입 비교표

| 타입 | 최대 차원 | 메모리 (1536차원) | 정확도 | 주요 용도 |
|------|----------|------------------|--------|----------|
| **vector (float32)** | 2,000 | 6,144 bytes | 100% | 정확도 최우선, 중소규모 |
| **halfvec (float16)** | 4,000 | 3,072 bytes | 98-99% | 중대규모, 메모리 절약 |
| **bit (binary)** | 64,000 | 192 bytes | 70-80% (단독)<br>95%+ (2-stage) | 초대규모, 1차 필터링 |
| **sparsevec** | N/A | 비영 요소만 | 100% | 추천 시스템, 하이브리드 검색 |

---

## 6) 거리 함수 연산자

pgvector는 벡터 간 유사도를 계산하는 여러 거리 함수를 제공합니다.

### 연산자 목록

| 연산자 | 거리 함수 | 설명 | 용도 |
|--------|----------|------|------|
| `<->` | L2 Distance (Euclidean) | 두 점 사이의 직선 거리. √((x₁-x₂)² + (y₁-y₂)²) | 일반적인 벡터 유사도, 이미지 검색 |
| `<=>` | Cosine Distance | 벡터 간 각도 차이. 1 - (A·B)/(‖A‖‖B‖). 크기 무시, 방향만 비교 | 문서/텍스트 유사도 (가장 많이 사용) |
| `<#>` | Inner Product | 두 벡터의 내적(음수 반환). -(A·B). 크기와 방향 모두 고려 | 추천 시스템, 협업 필터링 |
| `<+>` | L1 Distance (Manhattan) | 각 차원 차이의 절댓값 합. ‖x₁-x₂‖ + ‖y₁-y₂‖ | 고차원 희소 벡터, 특수 도메인 |
| `<~>` | Hamming Distance | 서로 다른 비트 개수. binary 전용 | 이진 벡터 검색, 중복 탐지 |
| `<%>` | Jaccard Distance | 1 - (교집합/합집합). binary 전용 | 집합 유사도, 태그 비교 |

### 사용 예시

```sql
-- ========================================
-- 거리 함수 연산자 예제
-- ========================================

-- 1. Cosine Distance (가장 일반적) - test1 사용
SELECT content, embedding <=> '[0.1, -0.9]' AS distance
FROM test1
ORDER BY distance
    LIMIT 10;

-- 2. L2 Distance (유클리드 거리) - test1 사용
SELECT content, embedding <-> '[0.1, -0.9]' AS distance
FROM test1
ORDER BY distance
    LIMIT 10;

-- 3. Inner Product (추천 시스템) - 신규 테이블 필요
CREATE TABLE test5 (
                       product_id BIGSERIAL PRIMARY KEY,
                       product_name TEXT,
                       embedding vector(2)
);

INSERT INTO test5 (product_name, embedding)
VALUES
    ('상품 A', '[0.8, 0.6]'),
    ('상품 B', '[0.3, 0.9]'),
    ('상품 C', '[-0.5, 0.7]');

-- Inner Product 검색 (사용자 선호도 벡터와 비교)
SELECT product_name, embedding <#> '[0.5, 0.5]' AS score
FROM test5
ORDER BY score DESC
    LIMIT 10;

-- 4. Hamming Distance (binary 벡터) - test3 사용
SELECT content, embedding_binary <~> B'10' AS distance
FROM test3
ORDER BY distance
    LIMIT 10;

-- 5. L1 Distance (Manhattan) - test1 사용
SELECT content, embedding <+> '[0.1, -0.9]' AS distance
FROM test1
ORDER BY distance
    LIMIT 10;

-- 6. Jaccard Distance (binary 전용) - test3 사용
SELECT content, embedding_binary <%> B'11' AS distance
FROM test3
ORDER BY distance
    LIMIT 10;
```

---

## 7) 타입 선택 가이드

> ⚠️ **PostgreSQL 벡터 검색 성능 제약**  
> 현재 pgvector는 벡터 데이터가 **100만 건을 넘어가면 성능 이슈**가 발생할 수 있습니다.  
> 대규모 벡터 검색(수백만~수억 건)이 필요한 경우, Pinecone, Milvus, Weaviate 등 전문 벡터 DB 사용을 권장합니다.


### 시나리오별 권장 타입

| 시나리오 | 데이터 규모 | 권장 타입 | 이유 |
|----------|------------|----------|------|
| **의미 검색 (RAG)** | ~100만 벡터 | vector (float32) | 정확도 최우선 |
| **의미 검색 (RAG)** | 100만~1000만 | halfvec (float16) | 메모리 절약, 정확도 유지 |
| **의미 검색 (RAG)** | 1억+ 벡터 | bit + vector (2-stage) | 속도와 비용 최적화 |
| **추천 시스템** | 모든 규모 | sparsevec | 희소성 활용 |
| **이미지 검색** | ~1000만 이미지 | halfvec | 메모리 효율 |
| **중복 탐지** | 모든 규모 | bit (binary) | 빠른 비교 |

### 의사결정 플로우

```
데이터 1억 개 이상?
├─ Yes → bit (binary) + vector (2-stage)
└─ No
    └─ 정확도 최우선?
        ├─ Yes → vector (float32)
        └─ No → halfvec (float16)
```

---

## 8) 타입 변환

### float32 → halfvec 변환

```sql
-- 새 테이블 생성
CREATE TABLE test6 AS
SELECT id, content, embedding::halfvec(2) as embedding
FROM test1;

-- 인덱스 재생성
CREATE INDEX ON test6 USING hnsw (embedding halfvec_cosine_ops);
```

### float32 → binary 변환

```python
import numpy as np

# float32 벡터를 binary로 변환
def to_binary(vector):
    return (np.array(vector) > 0).astype(int).tolist()

# PostgreSQL에 저장
binary_vec = to_binary(embedding)
cur.execute(
    "INSERT INTO documents_binary (content, embedding_binary) VALUES (%s, %s)",
    (text, binary_vec)
)
```

---

# 🎯 요약

- pgvector는 **4가지 벡터 타입**을 지원: vector, halfvec, bit, sparsevec
- **vector (float32)**: 정확도 최우선, 중소규모 데이터 (기본 선택)
- **halfvec (float16)**: 메모리 50% 절감, 정확도 98-99% 유지 (실무 권장)
- **bit (binary)**: 메모리 97% 절감, 2-stage 검색으로 정확도 복구 (초대규모)
- **sparsevec**: 희소 벡터 전용, 추천 시스템/하이브리드 검색
- **거리 함수**: Cosine Distance (`<=>`)가 텍스트 검색에 가장 많이 사용됨
- 서비스 규모와 요구사항에 따라 **적절한 타입 선택**이 성능과 비용에 큰 영향을 미침

---